#include <stdio.h>#include <string.h>#include <stdlib.h>#include "symbolTable.h"typedef struct {	char name[MAX_LBL_SZ + 1]; /* because there is '/0' in the end */	unsigned int isData: 1;	unsigned int isCode: 1;	unsigned int isEntry: 1;	unsigned int isExtern: 1;	int value;} symbol;typedef struct symbolNode {	symbol data;	struct symbolNode *next;} symbolNode;typedef struct entryNode {	char name[MAX_LBL_SZ + 1];	int lineNumber;	struct entryNode *next;} entryNode;typedef struct externNode {	char name[MAX_LBL_SZ + 1];	int IC;	struct externNode *next;} externNode;/* pointer for the symbol table (point on node in the table) */static symbolNode *head = NULL;static entryNode *entHead = NULL;static externNode *extHead = NULL;static int isEntryFile = FALSE;static symbol *symbolInTable(char *label);static symbol *symbolInTable(char *label) {	symbolNode *ptr = head;	/* scan the table and compare the label to the previous labels */	while (ptr != NULL) {		if (!strcmp(label, ptr->data.name))			return &(ptr->data);		ptr = ptr->next;	}	return NULL; /* symbol is not in table */}int addSymbol(char *label, int guide, int IC, int DC) {	symbolNode *newNode;	symbol data;	/* check if symbol is already in the table */	if (symbolInTable(label)) {		printf("error in %d: label is already defined\n", lineNumber);		return ERROR_CODE;	}	/* check label length */	if (strlen(label) > MAX_LBL_SZ) {		printf("error in %d: label is too long\n", lineNumber);		return ERROR_CODE;	}	/* create new node */	newNode = (symbolNode*) malloc(sizeof(symbolNode));	strcpy(data.name, label);	data.isData = ((guide == DATA) || (guide == STR));	data.isEntry = (guide == ENTRY);	data.isExtern = (guide == EXTERN);	data.isCode = ((guide == ENTRY) || (guide == EXTERN) || (guide == CODE));	data.value = (data.isData) ? DC : ((data.isExtern) ? 0 : IC + MMRY_OFFSET);	newNode->data = data;	newNode->next = head;	head = newNode; /* add the label to be the first in the list (order doesn't matter) */	return 0; /* success code */}int getValue(char *label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return ERROR_CODE; /* symbol is not in table */	return S->value;}int isSymbolExternal(char* label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return ERROR_CODE; /* symbol is not in table */	return S->isExtern;}void updateDataLabels(int ICF) {	symbolNode *ptr = head;	/* add the offset for all data symbols */	while (ptr != NULL) {		if (ptr->data.isData)			ptr->data.value += ICF;		ptr = ptr->next;	}}int getValueFromSymbol(char *label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return ERROR_CODE; /* symbol is not in table */	return S->value;}int addEntryNode(char *label) {	entryNode *newNode;	/* check label length */	if (strlen(label) > MAX_LBL_SZ) {		printf("error in %d: label is too long\n", lineNumber);		return ERROR_CODE;	}	/* create new node and set its data */	newNode = (entryNode*) malloc(sizeof(entryNode));	strcpy(newNode->name, label);	newNode->lineNumber = lineNumber;	newNode->next = entHead;	entHead = newNode; /* add the label to be the first in the list (order doesn't matter) */	return 0; /* success code */}int entrifyList(void) {	entryNode *entPtr = entHead, *forFree; /* used to free the entry list */	symbol *S;	int errorFlag = 0;	while (entPtr != NULL) {		/* search label in symbol table. if not exist, print error and return error code */		S = symbolInTable(entPtr->name);		if (S == NULL) { /* symbol doesn't exist */			printf("error in %d: a label (%s) defined as entry but never defined\n", entPtr->lineNumber, entPtr->name);			errorFlag = ERROR_CODE;		}		else {			isEntryFile = TRUE; /* mark that there is need to output .ent file */			S->isEntry = 1; /* set symbol to be entry */		}		/* go to the next node and free the previous line */		forFree = entPtr;		entPtr = entPtr->next;		free(forFree);	}	return errorFlag;}int addExternNode(char *label, int IC) {	externNode *newNode = (externNode*) malloc(sizeof(entryNode));	/* create new node and set its data */	strcpy(newNode->name, label);	newNode->IC = IC;	newNode->next = extHead;	extHead = newNode; /* add the label to be the first in the list (order doesn't matter) */	return 0; /* success code */}void printExtern(FILE* fp) {	externNode *extPtr = extHead, *forFree; /* used to free the extern list */	while (extPtr != NULL) {		/* print line to file (one line per extern occurance) */		fprintf(fp, "%s %07d\n", extPtr->name, extPtr->IC);		/* go to the next node and free the previous line */		forFree = extPtr;		extPtr = extPtr->next;		free(forFree);	}}void printEntry(FILE* fp) {	symbolNode *symbolPtr = head, *forFree; /* used to free the symbol table */	while (symbolPtr != NULL) {		/* print line to file (one line per extern occurance) */		if (symbolPtr->data.isEntry)			fprintf(fp, "%s %07d\n", symbolPtr->data.name, symbolPtr->data.value);		/* go to the next node and free the previous line */		forFree = symbolPtr;		symbolPtr = symbolPtr->next;		free(forFree);	}}int needEntFile(void) {	return isEntryFile;}int needExtFile(void) {	return (extHead != NULL);}