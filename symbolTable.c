#include <stdio.h>#include <string.h>#include <stdlib.h>#include "symbolTable.h"typedef struct entryNode {	char name[MAX_LBL_SZ + 1];	int lineNumber;	struct entryNode *next;} entryNode;/* pointer for the symbol table (point on node in the table) */symbolNode *head = NULL;static entryNode *entHead = NULL;symbol *symbolInTable(char *label) {	symbolNode *ptr = head;	/* scan the table and compare the label to the previous labels */	while (ptr != NULL) {		if (!strcmp(label, ptr->data.name))			return &(ptr->data);		ptr = ptr->next;	}	return NULL; /* symbol is not in table */}int addSymbol(char *label, int guide, int IC, int DC) {	symbolNode *newNode;	symbol data;	/* check if symbol is already in the table */	if (symbolInTable(label)) {		printf("error in %d: label is already defined\n", lineNumber);		return ERROR_CODE;	}	/* check label length */	if (strlen(label) > MAX_LBL_SZ) {		printf("error in %d: label is too long\n", lineNumber);		return ERROR_CODE;	}	/* create new node */	newNode = (symbolNode*) malloc(sizeof(symbolNode));	strcpy(data.name, label);	data.isData = ((guide == DATA) || (guide == STR));	data.isEntry = (guide == ENTRY);	data.isExtern = (guide == EXTERN);	data.isCode = ((guide == ENTRY) || (guide == EXTERN) || (guide == CODE));	data.value = (data.isData) ? DC : ((data.isExtern) ? 0 : IC + MMRY_OFFSET);	newNode->data = data;	newNode->next = head;	head = newNode; /* add the label to be the first in the list (order doesn't matter) */	return 0; /* success code */}int getValue(char *label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return -1; /* symbol is not in table */	return S->value;}int isSymbolExternal(char* label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return -1; /* symbol is not in table */	return S->isExtern;}void updateDataLabels(int ICF) {	symbolNode *ptr = head;	/* add the offset for all data symbols */	while (ptr != NULL) {		if (ptr->data.isData)			ptr->data.value += ICF;		ptr = ptr->next;	}}int getValueFromSymbol(char *label) {	symbol *S = symbolInTable(label);	if (S == NULL)		return -1; /* symbol is not in table */	return S->value;}int addEntryNode(char *label) {	entryNode *newNode;	/* check label length */	if (strlen(label) > MAX_LBL_SZ) {		printf("error in %d: label is too long\n", lineNumber);		return ERROR_CODE;	}	/* create new node and set its data */	newNode = (entryNode*) malloc(sizeof(entryNode));	strcpy(newNode->name, label);	newNode->lineNumber = lineNumber;	newNode->next = entHead;	entHead = newNode; /* add the label to be the first in the list (order doesn't matter) */	return 0; /* success code */}int entrifyList() {	entryNode *entPtr = entHead, *forFree; /* used to free the entry list */	symbol *S;	int errorFlag = 0;	while (entPtr != NULL) {		/* search label in symbol table. if not exist, print error and return error code */		S = symbolInTable(entPtr->name);		if (S == NULL) {			printf("error in %d: a label (%s) defined as entry but never defined\n", entPtr->lineNumber, entPtr->name);			errorFlag = ERROR_CODE;		}		/* set symbol to be entry */		S->isEntry = 1;		/* go to the next node and free the previous line */		forFree = entPtr;		entPtr = entPtr->next;		free(forFree);	}	return errorFlag;}/* finds the next entry label */symbolNode * findEntryLabel(symbolNode *ptr){	ptr = ptr->next;	while (ptr != NULL){		if ( ptr->data.isEntry )			return (ptr);		ptr = ptr->next;	}		return NULL;}int freeList(void) {	symbolNode *ptr = head;	symbolNode *temp = head;	/* add the offset for all data symbols */	while (ptr != NULL) {		temp = ptr->next;		free(ptr);		ptr = temp;	}		return 1;}